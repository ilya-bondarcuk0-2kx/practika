Проект строиться на 9 классах

1) Класс Book - базовый класс книги. В нем содержаться все поля и методы, которые присущи обычной книге, а так же виртуальный метод about(), который могут переопределять наследники.


2) Класс Encyclopedia - дочерний класс Book. В отличии от класса Book, содержит поля "sience" - наука, а так же в нем проявляется полиморфизм метода about().Данный класс объявлен как final - т.е. не наследников у него нет.


3) Класс Journal - дочерний класс Book. В отличии от класса Book, содержит поля "publisher" - издательство, а так же в нем проявляется полиморфизм метода about(). Данный класс объявлен как final - т.е. не наследников у него нет.


4) Класс Bookshelf - класс который содержит в себе контейнер типа Book*, а сам представляет из себя полку для книг. Данный класс объявлен как final - т.е. не наследников у него нет.


5) Класс Human - базовый абстрактный класс человека. Абстрактность данного класса сделана не с проста, она объясняется в классах наследниках.


6) Класс Employee - Наследник Human.Представляет сущность работника библиотеки (на базе данного класса можно создать экземпляр, с которым работает любая библиотека, ведь библиотеке в работниках не нужен просто Human, нужен именно работник). Отличается от Human двумя полями, stage - стаж работы , post - должность. Employee - final класс.


7) Класс Client - Наследник Human. Представляет сущность клиента (посетителя библиотеки). Объяснение почему нужны экземпляры именно этого класса в рамках моего проекта, аналогично классу Employee. Отличается от Human полем preferences - предпочтения. Данный класс также final

8) Класс Library - final класс. Представляет сущность самой библиотеки, и содержит три контейнера типов - Book*, Employee*, Client*

9) Класс Application - final класс. Представляет сущность приложения, откуда и начинается само действо. Здесь прописана вся логика и подключены все модули из которых собирается программа. Так же стоит отметить, что поля и методы класса - static, то есть вне зависимотси где будет расположен экземпляр класса Application и сколько их будет, состояние полей будет одинаковое.


P.S. Почему я делаю только delete library? Все просто, если отследить, что происходит в деструкторе класса library, можно увидеть, что там чиститься вся выделенная память, которая лежит в vector-ах всех типов, а так же очищаются сами векторы. В противном случае, если попробовать удалиить что-либо кроме library, будет вызвано исключение, из-за обращения к недоступной области памяти.
 